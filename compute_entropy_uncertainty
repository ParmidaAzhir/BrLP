# I wonder why I get corr of 0.6 and its wrong at the same time


import os
import numpy as np
import nibabel as nib
import matplotlib.pyplot as plt
BASE_DIR = r"P:\MRI_PREDICTIONS"
EPS = 1e-8
for subject in os.listdir(BASE_DIR):
    subject_path = os.path.join(BASE_DIR, subject)
    if not os.path.isdir(subject_path):
        continue
    pred_files = sorted([
        f for f in os.listdir(subject_path)
        if f.startswith("pred-mri-") and f.endswith(".nii.gz")
    ])
    if len(pred_files) != 64:
        print(f"Skip {subject} (only {len(pred_files)} prediction files)")
        continue
    print(f"Processing {subject}")
    # Load 64 scalar predictions (shape: [64, X, Y, Z])
    prediction_stack = []
    for f in pred_files:
        img = nib.load(os.path.join(subject_path, f))
        prediction_stack.append(img.get_fdata())
    prediction_stack = np.stack(prediction_stack, axis=0)  # Shape: [64, X, Y, Z]
    # Reshape for entropy: [X, Y, Z, 64]
    pred_flat = np.moveaxis(prediction_stack, 0, -1)  # Shape: [X, Y, Z, 64]
    # Sum over predictions per voxel
    sum_vals = np.sum(pred_flat, axis=-1, keepdims=True)
    # Replace zeros in sum to avoid division by zero
    sum_vals[sum_vals == 0] = EPS
    # Normalize to get pseudo-probabilities
    probs = pred_flat / sum_vals
    # Replace NaNs and infs safely
    probs = np.nan_to_num(probs, nan=0.0, posinf=0.0, neginf=0.0)
    # Compute entropy: -sum(p * log(p))
    entropy_map = -np.sum(probs * np.log(probs + EPS), axis=-1)
    # Clean final entropy map
    entropy_map = np.nan_to_num(entropy_map, nan=0.0, posinf=0.0, neginf=0.0)
    # Optional: Clip for visualization
    entropy_map = np.clip(entropy_map, 0, np.percentile(entropy_map, 95))
    # Debug print for sanity
    print(f"{subject}: Entropy min={entropy_map.min():.4f}, max={entropy_map.max():.4f}, mean={entropy_map.mean():.4f}")
    # Save NIfTI
    ref_img = nib.load(os.path.join(subject_path, pred_files[0]))
    entropy_img = nib.Nifti1Image(entropy_map, affine=ref_img.affine, header=ref_img.header)
    nib.save(entropy_img, os.path.join(subject_path, "uncertainty_entropy_map.nii.gz"))
    # Save central slice
    slice_idx = entropy_map.shape[2] // 2
    slice_data = entropy_map[:, :, slice_idx]
    plt.figure(figsize=(5, 5))
    plt.imshow(slice_data.T, cmap='hot', origin='lower')
    plt.colorbar(label='Entropy')
    plt.title(f"{subject} - Entropy (Scalar Predictions)")
    plt.axis('off')
    plt.savefig(os.path.join(subject_path, f"{subject}_entropy_uncertainty_slice.png"), bbox_inches='tight')
    plt.close()
print(" All entropy maps saved.")
